

			//sqlite3 *pMobDb;

			if ((nRet = _create_db(id, "bak", &pBackDb)) == SQLITE_OK)
				sqlite3_exec(pBackDb, "PRAGMA synchronous=OFF;PRAGMA journal_mode=OFF;", 0, 0, 0);
			else return nRet;

			if ((nRet = _create_db(id, "undo", &pUndoDb)) == SQLITE_OK) 
				sqlite3_exec(pUndoDb, "CREATE TABLE works (num INTEGER PRIMARY KEY AUTOINCREMENT DEFAULT 1, uid INT, snum INT DEFAULT 1, undo TEXT, redo TEXT);PRAGMA synchronous=OFF;PRAGMA journal_mode=OFF;", 0, 0, 0);
			else return nRet;

			//if ((nRet = sqlite3_open(":memory:", &pMobDb)) == SQLITE_OK) {
			//	sqlite3_exec(pMobDb, 
			//		"CREATE TABLE member (num INTEGER PRIMARY KEY AUTOINCREMENT DEFAULT 1, key CHAR(32), pwd CHAR(32), connected BOOL DEFAULT 0);"
			//		"CREATE TABLE received (uid INTEGER, snum INTEGER, base VARCHAR(1024), data TEXT, CONSTRAINT[] PRIMARY KEY(uid, snum));"
			//		"CREATE TABLE files (num INTEGER PRIMARY KEY AUTOINCREMENT DEFAULT 0, sent BOOL default 0, mtime TIMESTAMP, size INT64, uri VARCHAR(1024), path VARCHAR(1024));"
			//		"PRAGMA synchronous=OFF;PRAGMA journal_mode=OFF;", 0, 0, 0);
			//	if (alljoyn_is_server() == 1) sqlite3_exec(pMobDb, "INSERT INTO member (pwd) VALUES ('-');INSERT INTO member (pwd) VALUES ('12345678');", 0, 0, 0);
			//}
			//else return nRet;


/*

len = p2 - p;
if (len < 1024)	{
memcpy(fi.uri, p, len);
fi.mtime = get_file_mtime(p);
fi.fsize = get_file_length(p);

add2mem(data, &fi, sizeof(FILE_SEND_ITEM));
total += sizeof(FILE_SEND_ITEM);
}

QUERY_SQL_V(pMobDb, pStmt, ("SELECT mtime, size FROM files WHERE path=%Q AND sent=1", path),
if (mtime == sqlite3_column_int(pStmt, 0) && fsize == sqlite3_column_int64(pStmt, 1)) skip = 1;
break;
);

if (skip == 0) EXECUTE_SQL_V(pMobDb, ("INSERT INTO files (uri, path, mtime, size) VALUES (%Q, %Q, %d, %ld)", p, path, mtime, fsize));
*/


/*

if (total > 0) alljoyn_send(ACT_FLIST, wid, data, total);

char ** table = 0;
int rows = 0, cols = 0;

if (sqlite3_get_table(pMobDb, "SELECT uri, mtime, size FROM files WHERE sent=0", &table, &rows, &cols, 0) == SQLITE_OK) {
int r = 0, c;

while (++r <= rows) {
c = -1;
while (++c < cols) {
//s = table[r * cols + c];
}
}

alljoyn_send(ACT_FLIST, wid, table, redo.nUsed);
sqlite3_exec(pMobDb, "UPDATE sent=1 WHERE sent=0", 0, 0, 0);
}

if (table) sqlite3_free_table(table);
*/



* 세션 아이디 : doc id

* 사용자 문자열 : user id

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

* PKT_HEADER , body 로 발송하기

  int foot_print[16];
  int wid;  // doc id
  int action; // 0 데이터, 1 파일리스트 2 파일리스트 전송요청 3 파일
  int chain;

- data packet

  int chain;
  int length; // 양수이면 중간 음수이면 끝.
  char * data;

  바디 구조 (redo 테이블에 저장 uid, snum, base)

  int uid

  int snum

  char base[1024];

  char * data; 

* 맴버 테이블

  int uid;

  int connected;

  char pwd[32];

  char key[32]; // 개별 전송용

  - 변경이슈마다 개설자의 맴버 테이블 동기화(브로드케스팅).

* apply 테이블

  redo 테이블과 같은 구조 uid, snum, base, data

  압축 및 정리할것.

* 파일 uri 채취

- 실행시 임시폴더 초기화

- 파일 uri 를 채취하여 리스트로 만들기 및 전송(브로드케스팅)

  테이블 구조

  int num

  int uid

  int ftime

  int size

  varchar uri[1024]

  varchar path[1024] // saved path

  바디 구조

  int count;

{
  int uid;

  char uri[1024]; // original path uri: file://...

  int ftime; // modify

  int size;
}

- 리스트를 보내고 없거나 수정된 리스트만 전송 요청 (개별적)

- 파일 전송 (개별적)

  바디 구조

  int uid;

  char uri[1024]; // original path uri: file://...

  int ftime; // modify

  int size;

  char * data;

 ....................................................................................................................................................
 
  * PKT_HEADER

int foot_print[16];
int req;
int wid;  // doc id
int uid;  // 보내는이의 user id
int snum;
int fid;  // 파일인 경우 파일 id > 0 아니면 0
int chain; // 0 이면 시그널.
Str base;  // 대상이 되는 테이블(들)

* data packet

int chain;
int length; // 양수이면 중간 음수이면 끝.
char * data;

의 처리 결과 아래 핸들러로 들어감.

int SendHandler(int nDocID, int nUID, const char * sText, int nLength)
{
로그인일때 nUID == 0 , sText 는 패스워드 가능하면 

누적된 DB 를 정상 전송

아니면 에러 시그널

}

보낼때 
Send(int nDocID, int nUID, const char * sText, int nLength)
이면 file 들에 대한 처리후 본 데이터 처리.

alljoyn_send(const char * sText)
에서 

uid 이 0 이면 로그인

fid, chain 이 0 이면 시그널

로그인 에러이면 접속 종료후 term

로그인 성공이면 협업자 접속 리스트 갱신 전파 시그널

개설자 로그아웃 시그널이면 접속 종료후 term

협업자 로그아웃 시그널이면 맴버 종료후 동기화

개설자는 시작시 그동안의 묶음을 주고 시간이 뒤바뀐 다른 참여자의 데이터의 경우 누락복구로 수신.

그러므로 참여자는 예외처리없는 참여가 허용된다.

redo 의 키로 저장 (redo 에 uid, snum 기록)

redo 에 반영되기 직전 부모가 같으면 언두후 리두처리(redo 테이블 삽입후 처리)

도착한 데이터들은 처리를 위한 큐 테이블에 쌓인다.

member table, apply table 존재.

* 
....................................................................................................................................................

* PKT_HEADER

  int foot_print[16];
  int wid;  // doc id
  int uid;  // user id - login 인 경우 0
  int fid;  // 파일인 경우 파일 id > 0 아니면 0
  int chain;
  
* data packet

  int chain;
  int length; // 양수이면 중간 음수이면 끝.
  char * data;
  
* type 이 file 이면 수신자가 pkt 전송치를 삭제. 아니면 전송후 소멸

* 레코드중 파일 uri 를 포함한 문자열이 있다면 이를 파일 id 로 바꾸고 DB 에 보존 

  - 기존에 저장된 파일 URI 가 있다면(파일크기, 생성일, 변경일정보등이 일치한다면) 그 id 를 가져옴.
  
  - 기존에 있지만 변경된 것이면 역시 그 id 를 가져옴
  
* 생성된 파일 id 인 경우 전송하여 수신자 파일 DB 반영

* 수정된 파일 id 인 경우 전송하여 수신자 파일 DB 수정

* 그후 데이터 전송 - 수신자는 데이터내의 file_id:\\??? 를 변경함. 
